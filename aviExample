def simple_deep_diff(t1, t2, key_name=None):
    """
    A simple DeepDiff-like function.

    - Supports dicts, lists/tuples, primitive values.
    - If key_name is provided and both sides are a list of dicts
      containing that key, it will compare them by that key instead of by index.
      Example: key_name="appName" → paths like "ghost['b']".
    """
    diff = {
        "values_changed": {},
        "dictionary_item_added": [],
        "dictionary_item_removed": [],
        "iterable_item_added": [],
        "iterable_item_removed": [],
    }

    def make_path(parent, key):
        """Build a path string, replacing 'root' with the top-level key."""
        if parent in ("root", "", None):
            # Top level: just the appName or key itself
            return str(key)
        else:
            return f"{parent}['{key}']"

    def _diff(v1, v2, path):
        # Case 1: both are dicts
        if isinstance(v1, dict) and isinstance(v2, dict):
            keys1 = set(v1.keys())
            keys2 = set(v2.keys())

            # Added keys
            for k in sorted(keys2 - keys1):
                diff["dictionary_item_added"].append(make_path(path, k))

            # Removed keys
            for k in sorted(keys1 - keys2):
                diff["dictionary_item_removed"].append(make_path(path, k))

            # Keys in both → recurse
            for k in sorted(keys1 & keys2):
                _diff(v1[k], v2[k], make_path(path, k))

        # Case 2: both are lists/tuples
        elif isinstance(v1, (list, tuple)) and isinstance(v2, (list, tuple)):
            # Special case: list of dicts keyed by key_name (e.g. appName)
            if (
                key_name
                and all(isinstance(x, dict) and key_name in x for x in v1)
                and all(isinstance(x, dict) and key_name in x for x in v2)
            ):
                index1 = {d[key_name]: d for d in v1}
                index2 = {d[key_name]: d for d in v2}

                k1 = set(index1.keys())
                k2 = set(index2.keys())

                # New appNames
                for k in sorted(k2 - k1):
                    diff["dictionary_item_added"].append(make_path(path, k))

                # Removed appNames
                for k in sorted(k1 - k2):
                    diff["dictionary_item_removed"].append(make_path(path, k))

                # Common appNames → recurse into each dict
                for k in sorted(k1 & k2):
                    _diff(index1[k], index2[k], make_path(path, k))
            else:
                # Normal positional list comparison
                len1, len2 = len(v1), len(v2)
                max_len = max(len1, len2)

                for i in range(max_len):
                    if path:
                        item_path = f"{path}[{i}]"
                    else:
                        item_path = f"[{i}]"

                    if i >= len1:
                        diff["iterable_item_added"].append(item_path)
                    elif i >= len2:
                        diff["iterable_item_removed"].append(item_path)
                    else:
                        _diff(v1[i], v2[i], item_path)

        # Case 3: base / primitive values
        else:
            if v1 != v2:
                diff["values_changed"][path] = {
                    "old_value": v1,
                    "new_value": v2,
                }

    _diff(t1, t2, "root")

    # Clean empty sections
    return {k: v for k, v in diff.items() if v}
