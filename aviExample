import asyncio
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, AsyncIterator

import httpx


# ----------------- Config Model -----------------

@dataclass
class AviControllerConfig:
    controller_ip: str
    username: str
    password: str
    api_version: str
    tenant: str = "admin"
    verify: bool = False


# ----------------- Async Login -----------------

async def avi_login_async(
    client: httpx.AsyncClient,
    controller_ip: str,
    username: str,
    password: str
) -> bool:
    """Login to Avi controller and store cookies in client."""
    login_url = f"https://{controller_ip}/login"
    payload = {"username": username, "password": password}

    try:
        resp = await client.post(login_url, json=payload)
        if resp.status_code == 200:
            print(f"[{controller_ip}] Login successful.")
            return True
        else:
            print(f"[{controller_ip}] Login failed {resp.status_code}: {resp.text}")
            return False
    except httpx.RequestError as e:
        print(f"[{controller_ip}] Login error: {e}")
        return False


# ----------------- Avi Async Client Wrapper -----------------

class AviAsyncClient:
    """
    Async Avi API client using httpx.AsyncClient.
    - One instance per controller.
    - Handles login + re-login.
    - Provides get_objects_iter() for list endpoints.
    - Provides get_json() for single-object endpoints.
    """

    def __init__(self, cfg: AviControllerConfig):
        self.cfg = cfg
        self.client: Optional[httpx.AsyncClient] = None

    async def __aenter__(self) -> "AviAsyncClient":
        self.client = httpx.AsyncClient(
            base_url=f"https://{self.cfg.controller_ip}",
            verify=self.cfg.verify,
            headers={
                "Accept": "application/json",
                "Accept-Encoding": "application/json",
                "X-Avi-Version": self.cfg.api_version,
                "X-Avi-Tenant": self.cfg.tenant,
            },
            timeout=30.0,
            limits=httpx.Limits(
                max_connections=50,
                max_keepalive_connections=20,
            ),
            http2=False,  # set to True if controller supports HTTP/2
        )

        ok = await avi_login_async(
            self.client,
            self.cfg.controller_ip,
            self.cfg.username,
            self.cfg.password,
        )
        if not ok:
            raise RuntimeError(f"Login failed for {self.cfg.controller_ip}")
        return self

    async def __aexit__(self, exc_type, exc, tb):
        if self.client:
            await self.client.aclose()

    # ---------- Internal helper: GET with auto re-login ----------

    async def _get_with_relogin(
        self,
        url_or_path: str,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -> httpx.Response:
        assert self.client is not None
        resp = await self.client.get(url_or_path, params=params, headers=headers)

        # Session expired? Re-login once and retry
        if resp.status_code in (401, 419) or "Invalid session" in resp.text:
            print(f"[{self.cfg.controller_ip}] Session expired â†’ re-login...")
            ok = await avi_login_async(
                self.client,
                self.cfg.controller_ip,
                self.cfg.username,
                self.cfg.password,
            )
            if not ok:
                raise RuntimeError(f"Re-login failed for {self.cfg.controller_ip}")

            resp = await self.client.get(url_or_path, params=params, headers=headers)

        resp.raise_for_status()
        return resp

    # ---------- List-style endpoints: async iterator with pagination ----------

    async def get_objects_iter(
        self,
        resource: str,
        params: Optional[Dict[str, Any]] = None,
        tenant: Optional[str] = None,
    ) -> AsyncIterator[Dict[str, Any]]:
        """
        Async generator that yields ALL objects from Avi list endpoints.
        Uses ?page=&page_size=&count for pagination.
        Example resources:
            - 'virtualservice-inventory'
            - 'pool-inventory'
            - 'serviceengine'
            - 'serviceenginegroup-inventory'
            - 'cloud-inventory'
        """
        path = f"/api/{resource}"  # e.g. /api/virtualservice-inventory

        headers: Dict[str, str] = {}
        if tenant:
            headers["X-Avi-Tenant"] = tenant

        base_params: Dict[str, Any] = dict(params or {})
        base_params.setdefault("page_size", 200)

        page = 1
        total = None
        seen = 0

        while True:
            page_params = dict(base_params)
            page_params["page"] = page

            resp = await self._get_with_relogin(path, params=page_params, headers=headers)
            data = resp.json()

            if not isinstance(data, dict):
                break

            results = data.get("results") or data.get("items") or [data]
            if not isinstance(results, list) or not results:
                break

            if total is None:
                total = data.get("count")

            for obj in results:
                seen += 1
                yield obj

            if total is not None and seen >= total:
                break

            page += 1

    # ---------- Single-object endpoint helper ----------

    async def get_json(
        self,
        resource: str,
        params: Optional[Dict[str, Any]] = None,
        tenant: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        For endpoints that return a single JSON dict, e.g.:
            - 'licensing'
            - 'licensing/ledger/details'
            - 'systemconfiguration'
            - 'cluster/runtime'
        """
        path = f"/api/{resource}"
        headers: Dict[str, str] = {}
        if tenant:
            headers["X-Avi-Tenant"] = tenant

        resp = await self._get_with_relogin(path, params=params, headers=headers)
        return resp.json()

    # ---------- Option-specific helpers ----------

    async def fetch_virtualservice_inventory(self) -> List[Dict[str, Any]]:
        return [
            obj async for obj in self.get_objects_iter(
                "virtualservice-inventory",
                params={"include_name": True},
            )
        ]

    async def fetch_pool_inventory(self) -> List[Dict[str, Any]]:
        return [
            obj async for obj in self.get_objects_iter(
                "pool-inventory",
                params={"include_name": True},
            )
        ]

    async def fetch_serviceengine(self) -> List[Dict[str, Any]]:
        return [
            obj async for obj in self.get_objects_iter("serviceengine")
        ]

    async def fetch_serviceenginegroup_inventory(self) -> List[Dict[str, Any]]:
        return [
            obj async for obj in self.get_objects_iter("serviceenginegroup-inventory")
        ]

    async def fetch_cloud_inventory(self) -> List[Dict[str, Any]]:
        return [
            obj async for obj in self.get_objects_iter("cloud-inventory")
        ]

    async def fetch_licensing_ledger_details(self) -> Dict[str, Any]:
        return await self.get_json("licensing/ledger/details")

    async def fetch_licensing(self) -> Dict[str, Any]:
        return await self.get_json("licensing")

    async def fetch_systemconfiguration(self) -> Dict[str, Any]:
        return await self.get_json("systemconfiguration")

    async def fetch_cluster_runtime(self) -> Dict[str, Any]:
        return await self.get_json("cluster/runtime")

    # ---------- Optional: fetch multiple URLs from response ----------

    async def fetch_many_urls(self, urls: List[str]) -> List[Any]:
        """
        Given a list of URLs (absolute or relative), fetch them concurrently.
        You can use this for URLs found inside VS / pool JSON objects.
        """
        tasks = [self._get_with_relogin(url) for url in urls]
        responses = await asyncio.gather(*tasks, return_exceptions=True)

        results: List[Any] = []
        for r in responses:
            if isinstance(r, Exception):
                results.append({"error": str(r)})
            else:
                try:
                    results.append(r.json())
                except Exception as e:
                    results.append({"error": f"JSON decode failed: {e}"})
        return results


# ----------------- Per-Controller Orchestration -----------------

async def run_for_controller(cfg: AviControllerConfig) -> Dict[str, Any]:
    """
    For a single controller:
    - login
    - concurrently fetch all required resources
    - return a dict of all collected data
    """
    print(f"[{cfg.controller_ip}] Starting...")

    async with AviAsyncClient(cfg) as api:
        tasks = [
            api.fetch_virtualservice_inventory(),
            api.fetch_pool_inventory(),
            api.fetch_serviceengine(),
            api.fetch_serviceenginegroup_inventory(),
            api.fetch_licensing_ledger_details(),
            api.fetch_licensing(),
            api.fetch_cloud_inventory(),
            api.fetch_systemconfiguration(),
            api.fetch_cluster_runtime(),
        ]

        (
            vs_inv,
            pool_inv,
            se_list,
            seg_inv,
            lic_ledger,
            lic,
            cloud_inv,
            syscfg,
            cluster_rt,
        ) = await asyncio.gather(*tasks, return_exceptions=False)

        print(
            f"[{cfg.controller_ip}] Done. "
            f"VS={len(vs_inv)}, Pools={len(pool_inv)}, SE={len(se_list)}, SEG={len(seg_inv)}"
        )

        return {
            "controller": cfg.controller_ip,
            "virtualservice_inventory": vs_inv,
            "pool_inventory": pool_inv,
            "serviceengine": se_list,
            "serviceenginegroup_inventory": seg_inv,
            "licensing_ledger_details": lic_ledger,
            "licensing": lic,
            "cloud_inventory": cloud_inv,
            "systemconfiguration": syscfg,
            "cluster_runtime": cluster_rt,
        }


# ----------------- All Controllers Orchestration -----------------

async def main():
    # TODO: fill in your real controller IPs and credentials
    controllers: List[AviControllerConfig] = [
        AviControllerConfig("10.0.0.1", "admin", "password", "22.1.6", "admin", verify=False),
        AviControllerConfig("10.0.0.2", "admin", "password", "22.1.6", "admin", verify=False),
        # ... add up to 10 controllers here ...
    ]

    tasks = [run_for_controller(cfg) for cfg in controllers]
    results = await asyncio.gather(*tasks, return_exceptions=False)

    # Here you could write to DB, CSV, etc.
    for res in results:
        print(
            f"Controller {res['controller']} -> "
            f"VS={len(res['virtualservice_inventory'])}, "
            f"Pools={len(res['pool_inventory'])}"
        )


if __name__ == "__main__":
    asyncio.run(main())
