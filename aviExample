def simple_deep_diff(t1, t2, key_name=None, ignore_type_in_groups=None):
    """
    A simple DeepDiff-like function.

    - Supports dicts, lists/tuples, primitive values.
    - key_name: if provided and both sides are list of dicts with that key, use it
      to match items (e.g. appName -> ghost['b'] instead of root[0]['b']).
    - ignore_type_in_groups: list of tuples of types. Values whose types fall into
      the same group will be compared using a relaxed rule (e.g. by string form).
      Example: ignore_type_in_groups=[(None, str, int, bool)]
    """
    diff = {
        "values_changed": {},
        "dictionary_item_added": [],
        "dictionary_item_removed": [],
        "iterable_item_added": [],
        "iterable_item_removed": [],
    }

    # Normalize group definition: (None, str, int) -> (type(None), str, int)
    def _normalize_groups(groups):
        if not groups:
            return []
        norm = []
        for group in groups:
            norm_group = []
            for g in group:
                if g is None:
                    norm_group.append(type(None))
                else:
                    norm_group.append(g)
            norm.append(tuple(norm_group))
        return norm

    normalized_groups = _normalize_groups(ignore_type_in_groups)

    def in_same_ignore_group(v1, v2):
        """Return True if type(v1) and type(v2) are in the same ignore group."""
        if not normalized_groups:
            return False
        t1, t2 = type(v1), type(v2)
        for group in normalized_groups:
            if t1 in group and t2 in group:
                return True
        return False

    def values_equal(v1, v2):
        """
        Equality logic with optional ignore_type_in_groups.

        - If v1 == v2 normally, they are equal.
        - Else, if both types are in the same ignore group, compare by str().
        """
        if v1 == v2:
            return True

        if in_same_ignore_group(v1, v2):
            # Relaxed comparison: compare normalized string representations.
            # You can customize this (e.g. cast to int/float) if you like.
            return str(v1) == str(v2)

        return False

    def make_path(parent, key):
        """Build a path string; top level uses the key/appName directly."""
        if parent in ("root", "", None):
            return str(key)
        else:
            return f"{parent}['{key}']"

    def _diff(v1, v2, path):
        # Case 1: both are dicts
        if isinstance(v1, dict) and isinstance(v2, dict):
            keys1 = set(v1.keys())
            keys2 = set(v2.keys())

            # Added keys
            for k in sorted(keys2 - keys1):
                diff["dictionary_item_added"].append(make_path(path, k))

            # Removed keys
            for k in sorted(keys1 - keys2):
                diff["dictionary_item_removed"].append(make_path(path, k))

            # Keys in both → recurse
            for k in sorted(keys1 & keys2):
                _diff(v1[k], v2[k], make_path(path, k))

        # Case 2: both are lists/tuples
        elif isinstance(v1, (list, tuple)) and isinstance(v2, (list, tuple)):
            # Special case: list of dicts keyed by key_name (e.g. appName)
            if (
                key_name
                and all(isinstance(x, dict) and key_name in x for x in v1)
                and all(isinstance(x, dict) and key_name in x for x in v2)
            ):
                index1 = {d[key_name]: d for d in v1}
                index2 = {d[key_name]: d for d in v2}

                k1 = set(index1.keys())
                k2 = set(index2.keys())

                # New appNames
                for k in sorted(k2 - k1):
                    diff["dictionary_item_added"].append(make_path(path, k))

                # Removed appNames
                for k in sorted(k1 - k2):
                    diff["dictionary_item_removed"].append(make_path(path, k))

                # Common appNames → recurse into each dict
                for k in sorted(k1 & k2):
                    _diff(index1[k], index2[k], make_path(path, k))
            else:
                # Normal positional list comparison
                len1, len2 = len(v1), len(v2)
                max_len = max(len1, len2)

                for i in range(max_len):
                    if path:
                        item_path = f"{path}[{i}]"
                    else:
                        item_path = f"[{i}]"

                    if i >= len1:
                        diff["iterable_item_added"].append(item_path)
                    elif i >= len2:
                        diff["iterable_item_removed"].append(item_path)
                    else:
                        _diff(v1[i], v2[i], item_path)

        # Case 3: base / primitive values
        else:
            if not values_equal(v1, v2):
                diff["values_changed"][path] = {
                    "old_value": v1,
                    "new_value": v2,
                }

    _diff(t1, t2, "root")

    # Clean out empty sections
    return {k: v for k, v in diff.items() if v}
================================================

import re
from datetime import datetime

def format_diff_for_email(data_dict):
    changes = data_dict.get("values_changed", {})
    lines = []

    for full_key, change in changes.items():
        # Extract the last ['...'] part → e.g. "Freq_Daily_at"
        matches = re.findall(r"\['([^']+)'\]", full_key)
        key_name = matches[-1] if matches else full_key  # fallback to full key

        old_val = change.get("old_value")
        new_val = change.get("new_value")

        # Convert datetimes to string
        if isinstance(old_val, datetime):
            old_val = old_val.strftime("%Y-%m-%d %H:%M:%S.%f")
        if isinstance(new_val, datetime):
            new_val = new_val.strftime("%Y-%m-%d %H:%M:%S.%f")

        lines.append(f"The Key Changed: {key_name}")
        lines.append(f"New_value: {new_val}")
        lines.append(f"Old_value: {old_val}")
        lines.append("")  # blank line between entries

    return "\n".join(lines)
