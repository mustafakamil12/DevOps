import asyncio

async def _gather_manager_qas(
    index_uuid_list,
    qa_list,
    max_nodes: int = 16,            # limit concurrent nodes
    max_paths_per_node: int = 8,    # limit concurrent path-builds per node
):
    node_sem = asyncio.Semaphore(max_nodes)

    async def process_node(host, idx, uuid):
        async with node_sem:
            path_sem = asyncio.Semaphore(max_paths_per_node)

            async def build_one(qa_name: str):
                # throttle blocking work for this node
                async with path_sem:
                    # run blocking call in threadpool without blocking the event loop
                    return await asyncio.to_thread(_build_api_path, qa_name, uuid)

            coros = [build_one(qa) for qa in qa_list]
            paths = await asyncio.gather(*coros, return_exceptions=True)

            # normalize exceptions/None to empty strings so tuple shape is stable
            clean_paths = [p if isinstance(p, str) and p is not None else "" for p in paths]
            return (host, idx, uuid, *clean_paths)

    # fan-out across nodes, still bounded by node_sem
    return await asyncio.gather(*(process_node(h, i, u) for h, i, u in index_uuid_list))
