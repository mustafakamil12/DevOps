import threading
from ldap3 import Server, Connection, NTLM, TLS_CHANNEL_BINDING, NONE
from ldap3.core.exceptions import LDAPException

class LdapConnection:
    def __init__(self, host, user, password, tls, port=636, auto_referrals=False):
        self.host = host
        self.user = user
        self.password = password
        self.tls = tls
        self.port = port
        self.auto_referrals = auto_referrals

        self.server = Server(
            host,
            use_ssl=True,
            port=port,
            tls=tls,
            get_info=NONE
        )

        self._conn = None
        self._lock = threading.Lock()

    def connect(self):
        """
        Create + bind LDAP connection if missing or not bound.
        Reuses existing connection if already bound.
        """
        with self._lock:
            if self._conn and self._conn.bound:
                return self._conn

            # cleanup old connection if any
            if self._conn:
                try:
                    self._conn.unbind()
                except Exception:
                    pass
                self._conn = None

            # create new connection (NO retry)
            self._conn = Connection(
                self.server,
                user=self.user,
                password=self.password,
                authentication=NTLM,                   # use constant
                channel_binding=TLS_CHANNEL_BINDING,    # CBT
                auto_bind=True,
                auto_referrals=self.auto_referrals,
            )
            return self._conn

    def search(self, search_base, search_filter, attributes=None, size_limit=0):
        """
        Run LDAP search using the active connection.
        """
        conn = self.connect()

        ok = conn.search(
            search_base=search_base,
            search_filter=search_filter,
            attributes=attributes,
            size_limit=size_limit,
        )

        return ok, conn.entries

    def is_connected(self):
        """
        Returns True if connected and bound.
        """
        return bool(self._conn and self._conn.bound)

    def close(self):
        """
        Always clean up connection.
        """
        with self._lock:
            if self._conn:
                try:
                    self._conn.unbind()
                except Exception:
                    pass
                self._conn = None

    # Optional: allow "with LdapConnection(...) as ldap:"
    def __enter__(self):
        self.connect()
        return self

    def __exit__(self, exc_type, exc, tb):
        self.close()
=================
Another version without threading

from ldap3 import Server, Connection, NTLM, TLS_CHANNEL_BINDING, NONE

class LdapConnection:
    def __init__(self, host, user, password, tls, port=636, auto_referrals=False):
        self.host = host
        self.user = user
        self.password = password
        self.tls = tls
        self.port = port
        self.auto_referrals = auto_referrals

        self.server = Server(
            host,
            use_ssl=True,
            port=port,
            tls=tls,
            get_info=NONE
        )

        self._conn = None

    def connect(self):
        if self._conn and self._conn.bound:
            return self._conn

        # cleanup old connection if any
        if self._conn:
            try:
                self._conn.unbind()
            except Exception:
                pass
            self._conn = None

        self._conn = Connection(
            self.server,
            user=self.user,
            password=self.password,
            authentication=NTLM,
            channel_binding=TLS_CHANNEL_BINDING,
            auto_bind=True,
            auto_referrals=self.auto_referrals,
        )
        return self._conn

    def search(self, search_base, search_filter, attributes=None, size_limit=0):
        conn = self.connect()
        ok = conn.search(
            search_base=search_base,
            search_filter=search_filter,
            attributes=attributes,
            size_limit=size_limit,
        )
        return ok, conn.entries

    def close(self):
        if self._conn:
            try:
                self._conn.unbind()
            except Exception:
                pass
            self._conn = None

    def __enter__(self):
        self.connect()
        return self

    def __exit__(self, exc_type, exc, tb):
        self.close()

=================
Updated class

import re
from ldap3 import Server, Connection, NTLM, TLS_CHANNEL_BINDING, NONE, ALL
from ldap3.core.exceptions import LDAPException


class LdapConnection:
    def __init__(
        self,
        host: str,
        user: str,
        password: str,
        tls=None,
        port: int = 636,
        get_info=NONE,
        auto_referrals: bool = False,
        keep_open: bool = True,
        debug: bool = False,
    ):
        """
        keep_open=True  -> reuse one bound connection across calls (recommended to avoid DNS rotation)
        keep_open=False -> unbind after each query (more like your original behavior)
        """
        self.host = host
        self.user = user
        self.password = password
        self.tls = tls
        self.port = port
        self.get_info = get_info
        self.auto_referrals = auto_referrals
        self.keep_open = keep_open
        self.debug = debug

        # IMPORTANT: host should be plain hostname, not 'ldaps://...'
        self.server = Server(
            host,
            use_ssl=True,
            port=port,
            tls=tls,
            get_info=get_info
        )

        self.conn = None

    def connect(self):
        """
        Create + bind connection if not already bound.
        No retry logic (per your request).
        """
        if self.conn and self.conn.bound:
            return self.conn

        # cleanup old connection if any
        if self.conn:
            try:
                self.conn.unbind()
            except Exception:
                pass
            self.conn = None

        self.conn = Connection(
            self.server,
            user=self.user,
            password=self.password,
            authentication=NTLM,
            channel_binding=TLS_CHANNEL_BINDING,
            auto_bind=True,
            auto_referrals=self.auto_referrals,
        )

        if self.debug:
            print("successfully connect/bind")
            try:
                print("Peer:", self.conn.socket.getpeername())
            except Exception:
                pass

        return self.conn

    def close(self):
        """Explicitly close the LDAP session."""
        if self.conn:
            try:
                self.conn.unbind()
            except Exception:
                pass
            self.conn = None

    def query_groups(self, search_base: str, search_filter: str, attr: str, member=None, chkFlag: bool = False):
        """
        This mirrors your original function behavior:

        - If entries found and member is empty:
            - chkFlag True -> return True
            - else -> return conn.entries

        - If entries found and member provided:
            - build member list from entry['member'] DNs
            - if member matches:
                - return description if exists else cn
            - else return ''

        - If object not exist:
            - chkFlag True -> return False
            - else -> return []
        """
        conn = None
        try:
            conn = self.connect()

            if self.debug:
                print(f"conn now after checking: {conn}")
                print(f"search_base= {search_base}")
                print(f"search_filter= {search_filter}")
                print(f"attributes= {[attr]}")

            entries_ok = conn.search(
                search_base=search_base,
                search_filter=search_filter,
                attributes=[attr],
            )

            if self.debug:
                print(f"entries_ok: {entries_ok}")
                print(f"conn.entries: {conn.entries}")
                print(f"conn.entries count: {len(conn.entries)}")

            memberList = []

            if entries_ok:
                if not member:
                    if self.debug:
                        print("member is empty")

                    if chkFlag:
                        return True
                    return conn.entries

                # member provided:
                if self.debug:
                    print("There's member")

                for entry in conn.entries:
                    # Your original code expects entry['member'] to be iterable
                    # and each value to look like "CN=Name,OU=...,DC=..."
                    try:
                        for dn in entry["member"]:
                            match = re.findall(r'=(.*?),', str(dn))
                            if match:
                                memberList.append(match[0])
                    except Exception:
                        # if 'member' missing or not iterable, ignore for this entry
                        pass

                if self.debug:
                    print(f"memberList: {memberList}")

                for memberItem in memberList:
                    if memberItem == member:
                        # return description if exists else cn (same as your original)
                        if 'description' in conn.entries[0]:
                            return conn.entries[0]['description']
                        return conn.entries[0]['cn']
                    else:
                        # matches your original behavior: return '' as soon as first doesn't match
                        # NOTE: this logic is probably not what you intended, but you asked to reflect original.
                        return ''

                # if memberList empty, fall through to ''
                return ''

            # object not exist
            if self.debug:
                print("Object is not exist")

            if chkFlag:
                return False
            return []

        except LDAPException as e:
            # no retry here; bubble up (or you can return [] / False depending on your preference)
            raise

        finally:
            # Your choice:
            # - keep_open=True: keep the same bound connection for next call (best to reduce DNS rotation)
            # - keep_open=False: always unbind after each call (closer to old script style)
            if not self.keep_open:
                try:
                    if self.conn:
                        self.conn.unbind()
                except Exception:
                    pass
                self.conn = None


=================
How to use it

ldap_mgr = LdapConnection(
    host="dc01.company.local",
    user=user,
    password=password,
    tls=tls,
    auto_referrals=False,
)

ok, entries = ldap_mgr.search(
    search_base=search_base,
    search_filter=filter,
    attributes=[attr],
)

print(ok, len(entries))

ldap_mgr.close()


===================

using with

with LdapConnection("dc01.company.local", user, password, tls) as ldap_mgr:
    ok, entries = ldap_mgr.search(search_base, filter, attributes=[attr])
    print(len(entries))

