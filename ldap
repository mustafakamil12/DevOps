import threading
from ldap3 import Server, Connection, NTLM, TLS_CHANNEL_BINDING, NONE
from ldap3.core.exceptions import LDAPException

class LdapConnection:
    def __init__(self, host, user, password, tls, port=636, auto_referrals=False):
        self.host = host
        self.user = user
        self.password = password
        self.tls = tls
        self.port = port
        self.auto_referrals = auto_referrals

        self.server = Server(
            host,
            use_ssl=True,
            port=port,
            tls=tls,
            get_info=NONE
        )

        self._conn = None
        self._lock = threading.Lock()

    def connect(self):
        """
        Create + bind LDAP connection if missing or not bound.
        Reuses existing connection if already bound.
        """
        with self._lock:
            if self._conn and self._conn.bound:
                return self._conn

            # cleanup old connection if any
            if self._conn:
                try:
                    self._conn.unbind()
                except Exception:
                    pass
                self._conn = None

            # create new connection (NO retry)
            self._conn = Connection(
                self.server,
                user=self.user,
                password=self.password,
                authentication=NTLM,                   # use constant
                channel_binding=TLS_CHANNEL_BINDING,    # CBT
                auto_bind=True,
                auto_referrals=self.auto_referrals,
            )
            return self._conn

    def search(self, search_base, search_filter, attributes=None, size_limit=0):
        """
        Run LDAP search using the active connection.
        """
        conn = self.connect()

        ok = conn.search(
            search_base=search_base,
            search_filter=search_filter,
            attributes=attributes,
            size_limit=size_limit,
        )

        return ok, conn.entries

    def is_connected(self):
        """
        Returns True if connected and bound.
        """
        return bool(self._conn and self._conn.bound)

    def close(self):
        """
        Always clean up connection.
        """
        with self._lock:
            if self._conn:
                try:
                    self._conn.unbind()
                except Exception:
                    pass
                self._conn = None

    # Optional: allow "with LdapConnection(...) as ldap:"
    def __enter__(self):
        self.connect()
        return self

    def __exit__(self, exc_type, exc, tb):
        self.close()
=================
Another version without threading

from ldap3 import Server, Connection, NTLM, TLS_CHANNEL_BINDING, NONE

class LdapConnection:
    def __init__(self, host, user, password, tls, port=636, auto_referrals=False):
        self.host = host
        self.user = user
        self.password = password
        self.tls = tls
        self.port = port
        self.auto_referrals = auto_referrals

        self.server = Server(
            host,
            use_ssl=True,
            port=port,
            tls=tls,
            get_info=NONE
        )

        self._conn = None

    def connect(self):
        if self._conn and self._conn.bound:
            return self._conn

        # cleanup old connection if any
        if self._conn:
            try:
                self._conn.unbind()
            except Exception:
                pass
            self._conn = None

        self._conn = Connection(
            self.server,
            user=self.user,
            password=self.password,
            authentication=NTLM,
            channel_binding=TLS_CHANNEL_BINDING,
            auto_bind=True,
            auto_referrals=self.auto_referrals,
        )
        return self._conn

    def search(self, search_base, search_filter, attributes=None, size_limit=0):
        conn = self.connect()
        ok = conn.search(
            search_base=search_base,
            search_filter=search_filter,
            attributes=attributes,
            size_limit=size_limit,
        )
        return ok, conn.entries

    def close(self):
        if self._conn:
            try:
                self._conn.unbind()
            except Exception:
                pass
            self._conn = None

    def __enter__(self):
        self.connect()
        return self

    def __exit__(self, exc_type, exc, tb):
        self.close()

=================
Updated class

import re
from ldap3 import Server, Connection, NTLM, TLS_CHANNEL_BINDING, NONE
from ldap3.core.exceptions import LDAPException


class LdapConnection:
    def __init__(
        self,
        host: str,
        user: str,
        password: str,
        tls=None,
        port: int = 636,
        get_info=NONE,
        auto_referrals: bool = False,
        debug: bool = False,
    ):
        self.host = host
        self.user = user
        self.password = password
        self.tls = tls
        self.port = port
        self.get_info = get_info
        self.auto_referrals = auto_referrals
        self.debug = debug

        self.server = Server(
            host,               # no ldaps:// here
            use_ssl=True,
            port=port,
            tls=tls,
            get_info=get_info,
        )

        self.conn = None

    def __enter__(self):
        # auto connect/bind when entering the with block
        self.connect()
        return self

    def __exit__(self, exc_type, exc, tb):
        # always cleanup when leaving the with block
        self.close()

    def connect(self):
        if self.conn and self.conn.bound:
            return self.conn

        if self.conn:
            try:
                self.conn.unbind()
            except Exception:
                pass
            self.conn = None

        self.conn = Connection(
            self.server,
            user=self.user,
            password=self.password,
            authentication=NTLM,
            channel_binding=TLS_CHANNEL_BINDING,
            auto_bind=True,
            auto_referrals=self.auto_referrals,
        )

        if self.debug:
            print("successfully connect/bind")
            try:
                print("Peer:", self.conn.socket.getpeername())
            except Exception:
                pass

        return self.conn

    def close(self):
        if self.conn:
            try:
                self.conn.unbind()
            except Exception:
                pass
            self.conn = None

    def query_groups(self, search_base: str, search_filter: str, attr: str, member=None, chkFlag: bool = False):
        conn = self.connect()

        entries_ok = conn.search(
            search_base=search_base,
            search_filter=search_filter,
            attributes=[attr],
        )

        if not entries_ok:
            if chkFlag:
                return False
            return []

        if not member:
            if chkFlag:
                return True
            return conn.entries

        memberList = []
        for entry in conn.entries:
            try:
                for dn in entry["member"]:
                    match = re.findall(r'=(.*?),', str(dn))
                    if match:
                        memberList.append(match[0])
            except Exception:
                pass

        for memberItem in memberList:
            if memberItem == member:
                if 'description' in conn.entries[0]:
                    return conn.entries[0]['description']
                return conn.entries[0]['cn']
            else:
                return ""

        return ""



=================
How to use it

ldap_mgr = LdapConnection(
    host="dc01.company.local",
    user=user,
    password=password,
    tls=tls,
    auto_referrals=False,
)

ok, entries = ldap_mgr.search(
    search_base=search_base,
    search_filter=filter,
    attributes=[attr],
)

print(ok, len(entries))

ldap_mgr.close()


===================

using with

with LdapConnection("dc01.company.local", user, password, tls) as ldap_mgr:
    ok, entries = ldap_mgr.search(search_base, filter, attributes=[attr])
    print(len(entries))

===================

print("use_ssl:", conn.server.ssl)
print("port:", conn.server.port)
print("bound:", conn.bound)

# If this works, you are definitely on an SSL socket:
print("TLS version:", conn.socket.version())
print("Cipher:", conn.socket.cipher())

# Optional: show the server certificate subject (may be big)
cert = conn.socket.getpeercert()
print("Cert subject:", cert.get("subject"))
print("SAN:", cert.get("subjectAltName"))
