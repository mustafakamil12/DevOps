from __future__ import annotations

import json
import smtplib
import ssl
from dataclasses import dataclass
from email.message import EmailMessage
from typing import Any, Iterable, Literal, Optional

import logging

logger = logging.getLogger(__name__)

Severity = Literal["info", "warning", "error", "critical"]


@dataclass(frozen=True)
class EmailConfig:
    smtp_host: str
    smtp_port: int = 587
    username: Optional[str] = None
    password: Optional[str] = None
    use_tls: bool = True  # STARTTLS (587) typical
    from_addr: str = "noreply@company.com"
    timeout_seconds: float = 10.0

    # Default routing
    admin_recipients: tuple[str, ...] = ()
    user_recipients: tuple[str, ...] = ()


@dataclass(frozen=True)
class NotifyEvent:
    severity: Severity
    subject: str
    message: str
    payload: Optional[dict[str, Any]] = None
    to: Optional[Iterable[str]] = None  # override routing if provided
    tags: Optional[dict[str, Any]] = None  # e.g. job_id, request_id, component


class EmailNotifier:
    """
    Center point for sending emails.
    - Accepts text + dict payload
    - Provides consistent formatting
    - Keeps SMTP details out of business code
    """

    def __init__(self, cfg: EmailConfig):
        self.cfg = cfg

    def notify(self, event: NotifyEvent) -> None:
        recipients = tuple(event.to) if event.to else self._route(event)
        if not recipients:
            logger.warning("email notify skipped (no recipients)", extra={"payload": {"subject": event.subject}})
            return

        email = self._build_email(event, recipients)
        self._send(email, recipients)

    def _route(self, event: NotifyEvent) -> tuple[str, ...]:
        # Simple policy you can expand later:
        if event.severity in ("error", "critical"):
            return self.cfg.admin_recipients
        return self.cfg.user_recipients

    def _build_email(self, event: NotifyEvent, recipients: tuple[str, ...]) -> EmailMessage:
        msg = EmailMessage()
        msg["From"] = self.cfg.from_addr
        msg["To"] = ", ".join(recipients)
        msg["Subject"] = f"[{event.severity.upper()}] {event.subject}"

        # Plain text body (safe everywhere)
        lines: list[str] = []
        lines.append(event.message.strip())
        lines.append("")
        if event.tags:
            lines.append("Tags:")
            for k, v in event.tags.items():
                lines.append(f"  - {k}: {v}")
            lines.append("")

        if event.payload is not None:
            lines.append("Payload (JSON):")
            lines.append(json.dumps(event.payload, indent=2, default=str))

        msg.set_content("\n".join(lines))
        return msg

    def _send(self, msg: EmailMessage, recipients: tuple[str, ...]) -> None:
        try:
            if self.cfg.use_tls:
                context = ssl.create_default_context()
                with smtplib.SMTP(self.cfg.smtp_host, self.cfg.smtp_port, timeout=self.cfg.timeout_seconds) as server:
                    server.ehlo()
                    server.starttls(context=context)
                    server.ehlo()
                    if self.cfg.username and self.cfg.password:
                        server.login(self.cfg.username, self.cfg.password)
                    server.send_message(msg)
            else:
                with smtplib.SMTP(self.cfg.smtp_host, self.cfg.smtp_port, timeout=self.cfg.timeout_seconds) as server:
                    if self.cfg.username and self.cfg.password:
                        server.login(self.cfg.username, self.cfg.password)
                    server.send_message(msg)

            logger.info(
                "email sent",
                extra={"payload": {"to": list(recipients), "subject": msg["Subject"]}},
            )
        except Exception:
            # Don't crash your app because email failed.
            logger.exception(
                "email send failed",
                extra={"payload": {"to": list(recipients), "subject": msg.get("Subject")}},
            )


# ---------- Convenience functions (so modules can call in one line) ----------
_global_notifier: EmailNotifier | None = None


def init_notifier(cfg: EmailConfig) -> None:
    global _global_notifier
    _global_notifier = EmailNotifier(cfg)


def notify(
    *,
    severity: Severity,
    subject: str,
    message: str,
    payload: Optional[dict[str, Any]] = None,
    to: Optional[Iterable[str]] = None,
    tags: Optional[dict[str, Any]] = None,
) -> None:
    if _global_notifier is None:
        logger.warning("notifier not initialized; dropping notification", extra={"payload": {"subject": subject}})
        return

    _global_notifier.notify(
        NotifyEvent(
            severity=severity,
            subject=subject,
            message=message,
            payload=payload,
            to=to,
            tags=tags,
        )
    )


def notify_error(subject: str, message: str, payload: Optional[dict[str, Any]] = None, tags: Optional[dict[str, Any]] = None) -> None:
    notify(severity="error", subject=subject, message=message, payload=payload, tags=tags)


def notify_warning(subject: str, message: str, payload: Optional[dict[str, Any]] = None, tags: Optional[dict[str, Any]] = None) -> None:
    notify(severity="warning", subject=subject, message=message, payload=payload, tags=tags)
