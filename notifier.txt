from __future__ import annotations

import json
import logging
import smtplib
import ssl
import time
from dataclasses import dataclass
from email.message import EmailMessage
from typing import Any, Iterable, Literal, Optional, Protocol, Sequence

logger = logging.getLogger(__name__)

Severity = Literal["info", "warning", "error", "critical"]


# -----------------------------
# Config + Event
# -----------------------------
@dataclass(frozen=True)
class EmailConfig:
    smtp_host: str
    smtp_port: int = 587

    username: Optional[str] = None
    password: Optional[str] = None

    # STARTTLS on 587 is common; for SMTPS (implicit TLS) use 465 + use_starttls=False + use_smtps=True
    use_starttls: bool = True
    use_smtps: bool = False

    from_addr: str = "noreply@company.com"
    timeout_seconds: float = 10.0

    # Default routing
    admin_recipients: tuple[str, ...] = ()
    user_recipients: tuple[str, ...] = ()

    # Simple resilience
    max_retries: int = 2
    retry_backoff_seconds: float = 0.7  # exponential backoff base


@dataclass(frozen=True)
class NotifyEvent:
    severity: Severity
    subject: str
    message: str

    payload: Optional[dict[str, Any]] = None     # structured info
    tags: Optional[dict[str, Any]] = None        # job_id/request_id/component/etc.

    # Optional explicit recipients override
    to: Optional[Sequence[str]] = None


# -----------------------------
# Interfaces
# -----------------------------
class Notifier(Protocol):
    def notify(self, event: NotifyEvent) -> None: ...


# -----------------------------
# Email implementation
# -----------------------------
class EmailNotifier:
    """
    Enterprise-friendly email notifier:
      - No globals
      - Consistent formatting
      - Routing by severity (admins vs users)
      - Safe: failures never crash app
      - Optional retries with backoff
    """

    def __init__(self, cfg: EmailConfig) -> None:
        self._cfg = cfg

        if cfg.use_starttls and cfg.use_smtps:
            raise ValueError("Choose either use_starttls=True or use_smtps=True, not both.")

    def notify(self, event: NotifyEvent) -> None:
        recipients = tuple(event.to) if event.to else self._route(event)
        if not recipients:
            logger.warning(
                "email notify skipped (no recipients)",
                extra={"payload": {"subject": event.subject, "severity": event.severity}},
            )
            return

        msg = self._build_message(event, recipients)
        self._send_with_retries(msg, recipients, event)

    def _route(self, event: NotifyEvent) -> tuple[str, ...]:
        # Simple default policy (expand as needed):
        if event.severity in ("error", "critical"):
            return self._cfg.admin_recipients
        return self._cfg.user_recipients

    def _build_message(self, event: NotifyEvent, recipients: tuple[str, ...]) -> EmailMessage:
        msg = EmailMessage()
        msg["From"] = self._cfg.from_addr
        msg["To"] = ", ".join(recipients)
        msg["Subject"] = f"[{event.severity.upper()}] {event.subject}"

        lines: list[str] = []
        lines.append(event.message.strip())
        lines.append("")

        if event.tags:
            lines.append("Tags:")
            for k, v in event.tags.items():
                lines.append(f"  - {k}: {v}")
            lines.append("")

        if event.payload is not None:
            lines.append("Payload (JSON):")
            lines.append(json.dumps(event.payload, indent=2, default=str))

        msg.set_content("\n".join(lines))
        return msg

    def _send_with_retries(
        self,
        msg: EmailMessage,
        recipients: tuple[str, ...],
        event: NotifyEvent,
    ) -> None:
        attempts = max(1, int(self._cfg.max_retries) + 1)

        for attempt in range(1, attempts + 1):
            try:
                self._send(msg)
                logger.info(
                    "email sent",
                    extra={"payload": {"to": list(recipients), "subject": msg["Subject"], "attempt": attempt}},
                )
                return
            except Exception as e:
                # Never crash app due to email
                logger.exception(
                    "email send failed",
                    extra={
                        "payload": {
                            "to": list(recipients),
                            "subject": msg.get("Subject"),
                            "attempt": attempt,
                            "max_attempts": attempts,
                            "error_type": type(e).__name__,
                        }
                    },
                )
                if attempt < attempts:
                    sleep_s = self._cfg.retry_backoff_seconds * (2 ** (attempt - 1))
                    time.sleep(sleep_s)

    def _send(self, msg: EmailMessage) -> None:
        cfg = self._cfg

        context = ssl.create_default_context()

        if cfg.use_smtps:
            with smtplib.SMTP_SSL(cfg.smtp_host, cfg.smtp_port, timeout=cfg.timeout_seconds, context=context) as server:
                if cfg.username and cfg.password:
                    server.login(cfg.username, cfg.password)
                server.send_message(msg)
            return

        with smtplib.SMTP(cfg.smtp_host, cfg.smtp_port, timeout=cfg.timeout_seconds) as server:
            server.ehlo()
            if cfg.use_starttls:
                server.starttls(context=context)
                server.ehlo()
            if cfg.username and cfg.password:
                server.login(cfg.username, cfg.password)
            server.send_message(msg)


# -----------------------------
# Optional: composition helpers
# -----------------------------
class MultiNotifier:
    """
    Fan-out notifier: send to multiple channels (email today, add Slack/Teams later).
    """
    def __init__(self, notifiers: Iterable[Notifier]) -> None:
        self._notifiers = tuple(notifiers)

    def notify(self, event: NotifyEvent) -> None:
        for n in self._notifiers:
            try:
                n.notify(event)
            except Exception:
                # Defensive: a buggy notifier should not break the others
                logger.exception("notifier failed", extra={"payload": {"notifier": type(n).__name__}})
