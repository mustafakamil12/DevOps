# Asyncio Version
import asyncio
from datetime import datetime, timezone
from typing import Dict, Any
import pandas as pd

async def process_qa(node: str, mgr_node_uuid: str, qa_name: str) -> Dict[str, Any]:
    path = s.get_api_path(qa_name)
    if not path:
        return {}

    if "{node_uuid}" in path:
        path = path.format(node_uuid=mgr_node_uuid)

    mgr_configs = await asyncio.to_thread(s.NsxManagerConfigs, vip=node, api_path=path)
    check_conf = getattr(mgr_configs, qa_name)
    return await asyncio.to_thread(check_conf)

async def process_node(node: str, df: pd.DataFrame, qa_list: list[str]) -> Dict[str, Any]:
    TIME_STAMP = datetime.now(timezone.utc).strftime("%m-%d-%Y %H:%M:%S UTC")
    row_index = df.index[df["manager_fqdn"] == node].to_list()[0]
    mgr_node_uuid = df.loc[row_index, "manager_uuid"]

    results = {"row_index": row_index, "time_stamp": TIME_STAMP}
    qa_tasks = [
        process_qa(node, mgr_node_uuid, qa_name)
        for qa_name in qa_list
    ]
    qa_results = await asyncio.gather(*qa_tasks)

    for qa_dict in qa_results:
        for k, v in qa_dict.items():
            results[k] = v
    return results

async def nsx_mgr_qa_async(mgr_pd_df: pd.DataFrame) -> pd.DataFrame:
    df = mgr_pd_df.copy()

    if "time_stamp" not in df.columns:
        df["time_stamp"] = ""
    col = df.pop("time_stamp")
    df.insert(0, "time_stamp", col)

    mgr_list = df["manager_fqdn"].to_list()
    mgr_qa_list = ["get_mgr_motd", "get_mgr_dns", "get_mgr_ntp", "get_mgr_syslog", "get_mgr_tls",
                   "get_mgr_forwarding_mode", "get_mgr_search_domain", "get_mgr_backup", "get_mgr_users"]

    all_node_tasks = [process_node(node, df, mgr_qa_list) for node in mgr_list]
    all_results = await asyncio.gather(*all_node_tasks)

    # Write results back to df
    for result in all_results:
        row_index = result.pop("row_index")
        df.at[row_index, "time_stamp"] = result.pop("time_stamp")
        for k, v in result.items():
            if k not in df.columns:
                df[k] = ""
            df.at[row_index, k] = v

    return df
# ============================

# Multithreading version

from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime, timezone
import pandas as pd

def process_node_threaded(node: str, df: pd.DataFrame, qa_list: list[str]) -> dict:
    TIME_STAMP = datetime.now(timezone.utc).strftime("%m-%d-%Y %H:%M:%S UTC")
    row_index = df.index[df["manager_fqdn"] == node].to_list()[0]
    mgr_node_uuid = df.loc[row_index, "manager_uuid"]

    result = {"row_index": row_index, "time_stamp": TIME_STAMP}
    for qa_name in qa_list:
        path = s.get_api_path(qa_name)
        if not path:
            continue
        if "{node_uuid}" in path:
            path = path.format(node_uuid=mgr_node_uuid)

        mgr_configs = s.NsxManagerConfigs(vip=node, api_path=path)
        check_conf = getattr(mgr_configs, qa_name)
        qa_data = check_conf()
        result.update(qa_data)
    return result

def nsx_mgr_qa_threaded(mgr_pd_df: pd.DataFrame) -> pd.DataFrame:
    df = mgr_pd_df.copy()

    if "time_stamp" not in df.columns:
        df["time_stamp"] = ""
    col = df.pop("time_stamp")
    df.insert(0, "time_stamp", col)

    mgr_list = df["manager_fqdn"].to_list()
    mgr_qa_list = ["get_mgr_motd", "get_mgr_dns", "get_mgr_ntp", "get_mgr_syslog", "get_mgr_tls",
                   "get_mgr_forwarding_mode", "get_mgr_search_domain", "get_mgr_backup", "get_mgr_users"]

    with ThreadPoolExecutor(max_workers=10) as executor:
        future_to_node = {
            executor.submit(process_node_threaded, node, df, mgr_qa_list): node
            for node in mgr_list
        }

        for future in as_completed(future_to_node):
            result = future.result()
            row_index = result.pop("row_index")
            df.at[row_index, "time_stamp"] = result.pop("time_stamp")
            for k, v in result.items():
                if k not in df.columns:
                    df[k] = ""
                df.at[row_index, k] = v

    return df

# ============
# time wraper

import time
from functools import wraps

def benchmark(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        mode = kwargs.get("mode", "unknown").upper()
        print(f"\nüöÄ Starting nsx_mgr_qa in {mode} mode...")
        start = time.perf_counter()
        result = func(*args, **kwargs)
        end = time.perf_counter()
        print(f"‚úÖ Completed in {end - start:.2f} seconds.")
        return result
    return wrapper


# ===============
# Combined versions

import pandas as pd
from datetime import datetime, timezone
from typing import Dict, Any, Optional, Literal
import asyncio
from concurrent.futures import ThreadPoolExecutor, as_completed

# Dummy import placeholder (replace with actual logic)
# import s

QA_LIST = [
    "get_mgr_motd", "get_mgr_dns", "get_mgr_ntp", "get_mgr_syslog", "get_mgr_tls",
    "get_mgr_forwarding_mode", "get_mgr_search_domain", "get_mgr_backup", "get_mgr_users"
]

# --- Shared Utilities ---
def get_time_stamp() -> str:
    return datetime.now(timezone.utc).strftime("%m-%d-%Y %H:%M:%S UTC")

# --- Threaded Logic ---
def process_node_threaded(node: str, df: pd.DataFrame) -> dict:
    row_index = df.index[df["manager_fqdn"] == node].to_list()[0]
    uuid = df.loc[row_index, "manager_uuid"]
    result = {"row_index": row_index, "time_stamp": get_time_stamp()}

    for qa in QA_LIST:
        path = s.get_api_path(qa)
        if not path:
            continue
        path = path.format(node_uuid=uuid) if "{node_uuid}" in path else path
        mgr_configs = s.NsxManagerConfigs(vip=node, api_path=path)
        result.update(getattr(mgr_configs, qa)())
    return result

# --- Async Logic ---
async def process_qa_async(node: str, uuid: str, qa: str) -> dict:
    path = s.get_api_path(qa)
    if not path:
        return {}
    path = path.format(node_uuid=uuid) if "{node_uuid}" in path else path
    mgr_configs = await asyncio.to_thread(s.NsxManagerConfigs, vip=node, api_path=path)
    check_conf = getattr(mgr_configs, qa)
    return await asyncio.to_thread(check_conf)

async def process_node_async(node: str, df: pd.DataFrame) -> dict:
    row_index = df.index[df["manager_fqdn"] == node].to_list()[0]
    uuid = df.loc[row_index, "manager_uuid"]
    tasks = [process_qa_async(node, uuid, qa) for qa in QA_LIST]
    results = await asyncio.gather(*tasks)
    output = {"row_index": row_index, "time_stamp": get_time_stamp()}
    for qa_dict in results:
        output.update(qa_dict)
    return output

# --- Master Wrapper ---
def nsx_mgr_qa(df: pd.DataFrame, mode: Literal["sync", "threaded", "async"] = "sync") -> pd.DataFrame:
    df = df.copy()
    if "time_stamp" not in df.columns:
        df["time_stamp"] = ""
    df.insert(0, "time_stamp", df.pop("time_stamp"))

    mgr_list = df["manager_fqdn"].tolist()

    if mode == "sync":
        for node in mgr_list:
            row_index = df.index[df["manager_fqdn"] == node].to_list()[0]
            uuid = df.loc[row_index, "manager_uuid"]
            df.at[row_index, "time_stamp"] = get_time_stamp()
            for qa in QA_LIST:
                path = s.get_api_path(qa)
                if not path:
                    continue
                path = path.format(node_uuid=uuid) if "{node_uuid}" in path else path
                mgr_configs = s.NsxManagerConfigs(vip=node, api_path=path)
                result = getattr(mgr_configs, qa)()
                for k, v in result.items():
                    if k not in df.columns:
                        df[k] = ""
                    df.at[row_index, k] = v
        return df

    elif mode == "threaded":
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(process_node_threaded, node, df) for node in mgr_list]
            for future in as_completed(futures):
                result = future.result()
                row = result.pop("row_index")
                df.at[row, "time_stamp"] = result.pop("time_stamp")
                for k, v in result.items():
                    if k not in df.columns:
                        df[k] = ""
                    df.at[row, k] = v
        return df

    elif mode == "async":
        async def run_all():
            tasks = [process_node_async(node, df) for node in mgr_list]
            results = await asyncio.gather(*tasks)
            for result in results:
                row = result.pop("row_index")
                df.at[row, "time_stamp"] = result.pop("time_stamp")
                for k, v in result.items():
                    if k not in df.columns:
                        df[k] = ""
                    df.at[row, k] = v
            return df
        return asyncio.run(run_all())

    else:
        raise ValueError(f"Unsupported mode: {mode}")

#====================================================

üéØ Kerberos Role in Your App
üîê Auth Mechanism for Module A
Kerberos is used to authenticate Module A to SQL Server without using a username/password ‚Äî it uses a ticket instead.

üéüÔ∏è Issues a Ticket (TGT)
Kerberos authenticates the service account (e.g., via kinit) and provides a Ticket Granting Ticket (TGT).

üìú Provides Session Credentials
That TGT is used to get a service ticket for MSSQL (MSSQLSvc/hostname:port) so Module A can connect securely.

üõ°Ô∏è Enables Integrated Security
SQL Server checks the Kerberos ticket and allows access only if valid ‚Äî no need to store SQL passwords.

üé≠ Keytab Automation (optional)
In containers, Kerberos can use a keytab file to auto-login the service account instead of prompting for passwords.


